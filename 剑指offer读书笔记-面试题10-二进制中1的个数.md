---
title: 剑指offer读书笔记-面试题10-二进制中1的个数
date: 2018-01-26 15:53:30 
comments: false
tags:
  - 剑指offer
  - 算法
  - 移位运算
categories:
  - 算法
  - 剑指offer
---

# 问题描述 #

请实现一个函数，输入一个整数，输出该整数二进制表示中1的个数。
例如把9的二进制是1001，有2位是1。因此，如果输入9，该函数输出2。

## 相关知识点 ##

1. 相同位的两个数字都为1，则为1；若有一个不为1，则为0，即：1&1=1、1&0=0、0&1=1、0&0=1
2. 正数的右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可
3. 负数的右移，就是补码高位补1,然后按位取反加1即可

# 解决算法 #

## 算法一 ##

根据题目，我们可以想到通过右移的方式，一位一位的判断最低位是否为1，当最高位右移到最低位时就可得到有多少位是1，那么问题就来了，如和判断最低位是否为1。

根据与运算的性质可知：1&1=1、1&0=0，那么最低位和1进行与操作，若结果为1则表示最低位为1，否则为0。

那么算法可总结为：将整数与1进行与操作，若结果为1，则最低位为1，1的个数加1，然后把整数向右移一位，重复上述操作，直至整数变为0。

### 示例 ###

例如，求整数13的二进制中1的个数，过程如下：

整数13对应的二进制表示为：00000000 00000000 00000000 00001101。 

> java中int为4字节（4byte）共32位（32bit）。

第一步，整数和1进行与运算，结果为1，最低位为1，1的个数为1：
　00000000 00000000 00000000 00001101
& 00000000 00000000 00000000 00000001
= 00000000 00000000 00000000 00000001

第二步，整数右移一位，和1进行与运算，结果为0，最低位不为1：
　00000000 00000000 00000000 00000110
& 00000000 00000000 00000000 00000001
= 00000000 00000000 00000000 00000000

第三步，整数右移一位，和1进行与运算，结果为1，最低位为1，1的个数加1：
　00000000 00000000 00000000 00000011
& 00000000 00000000 00000000 00000001
= 00000000 00000000 00000000 00000001

第四步，整数右移一位，和1进行与运算，结果为1，最低位为1，1的个数加1：
　00000000 00000000 00000000 00000001
& 00000000 00000000 00000000 00000001
= 00000000 00000000 00000000 00000001

第五步，整数右移一位，和1进行与运算，结果为0，最低位不为1：
　00000000 00000000 00000000 00000000
& 00000000 00000000 00000000 00000001
= 00000000 00000000 00000000 00000000

整数右移后为0，结束，最后得到二进制中1的个数为3。

但是上边的算法有个小问题。由于计算机机中数值是以补码的形式存在，对于负数来说，对补码右移过程中最高位需补1而不是补0，当最高位移到最低位时，二进制的每一位上都为1，这就导致二进制表示中会有无限个1，右移过程陷入了死循环中。因此，对于负数，需要进行无操作符的右移，才能避免上述情况的发生。

> 对于负数的右移，可参考另一篇博文[《右移运算符总结》](http://zhangyida.cn/2018/01/23/%E5%89%91%E6%8C%87offer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%9D%A2%E8%AF%95%E9%A2%989-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98/)

### 代码 ###

```java
 public int NumberOf1(int n) {
	 int count = 0;
	 
	 while(n!=0) {
		//判断当前位置是否为1
		 if((n&1)==1) {
			 count++;
		 }
		 
		 //对n进行逻辑右移操作（无符号右移）
		 n=n>>>1;
	 }
	 
	 return count;
 }
```


## 算法二 ##


```java
public int Numberof12(int n) {
	 int count = 0;
	 int flag = 1;
	 
	 while(flag != 0) {
		 //判断当前位置是否为1
		 if(1 == (n & flag)) {
			 count++;
		 }
		 //对1进行左移操作
		 flag = flag<<1;
	 }
	 
	 return count;
 }
```

## 算法三 ##

```java
public int Numberof13(int n) {
 //n 和 n-1 进行与操作，能进行多少次与操作，就有多少个1
 int count = 0;
 
 while(n != 0) {
	 count++;
	 n = n & (n-1);
 }
	 
 return count;
}
```

附：

完整代码可参考github，地址为：
https://github.com/zhangyihao/Algorithms/blob/master/com.zhangyihao.algorithms/src/com/zhangyihao/algorithms/offer/Question10.java